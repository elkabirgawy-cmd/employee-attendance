================================================================================
              RACE CONDITION FIX - BEFORE vs AFTER
================================================================================

PROBLEM SCENARIO:
  User logs in as EMP001 → switches to EMP002 → switches to EMP003
  
  BEFORE FIX:
    ❌ EMP001 branch fetch completes AFTER switching to EMP003
    ❌ Shows "فشل تحميل بيانات الفرع" for EMP003 (wrong!)
    ❌ Then GPS validates against EMP001's branch (wrong!)
    ❌ Shows "تم التحقق من موقعك" even when outside EMP003's branch
  
  AFTER FIX:
    ✅ EMP001 branch fetch ignored (requestId mismatch)
    ✅ Only EMP003 branch data used for validation
    ✅ GPS validates against EMP003's branch only
    ✅ Correct message for EMP003's actual location

================================================================================

BEFORE: Multiple State Variables (Conflicting Sources)
--------------------------------------------------------------------------------

const [location, setLocation] = useState(null);
const [gpsError, setGpsError] = useState('');
// No unified status, no versioning

const getSmartStatus = () => {
  if (gpsError) return { text: gpsError, ... };        // Check 1
  if (!location) return { text: 'loading', ... };      // Check 2
  if (!isInGeofence()) return { text: 'outside', ... }; // Check 3
  return { text: 'ready', ... };                       // Check 4
};

// PROBLEM: Which check wins? They can conflict!
// - gpsError might be from old employee
// - location might be validated against old branch
// - isInGeofence() uses current employee but old location

AFTER: Unified Status Enum (Single Source)
--------------------------------------------------------------------------------

type AttendanceStatus = 'loading' | 'branch_error' | 'out_of_branch' | ...;
const [attendanceStatus, setAttendanceStatus] = useState('loading');
const requestIdRef = useRef(0);

// Compute status in strict order
useEffect(() => {
  if (!branchLoaded) {
    setAttendanceStatus('branch_error');  // Priority 1
    return;
  }
  if (gpsError) {
    setAttendanceStatus('gps_error');     // Priority 2
    return;
  }
  if (!location) {
    setAttendanceStatus('loading');       // Priority 3
    return;
  }
  if (distance > radius) {
    setAttendanceStatus('out_of_branch'); // Priority 4
    return;
  }
  setAttendanceStatus('ready');           // Priority 5
}, [branchLoaded, gpsError, location]);

const getSmartStatus = () => {
  switch (attendanceStatus) {             // Single check!
    case 'branch_error': return { text: 'فشل تحميل...', ... };
    case 'out_of_branch': return { text: 'خارج النطاق...', ... };
    // ... other cases
  }
};

// SOLUTION: Only one status at a time, no conflicts!

================================================================================

BEFORE: No Request Versioning (Stale Updates)
--------------------------------------------------------------------------------

async function handleLogin() {
  const empData = await fetchEmployee();  // Takes 500ms
  
  // User might have switched to different employee!
  // But we still update state with old employee data
  setEmployee(empData);                   // ❌ Wrong employee!
  setBranch(empData.branches);            // ❌ Wrong branch!
}

useEffect(() => {
  watchLocation((loc) => {
    setLocation(loc);                     // ❌ Updates for ANY employee!
  });
}, [isLoggedIn]);  // Doesn't re-create watch on employee change

AFTER: Request Versioning (Ignore Stale Updates)
--------------------------------------------------------------------------------

async function handleLogin() {
  resetAttendanceState();                 // requestId: 1 → 2
  const currentRequestId = requestIdRef.current;
  
  const empData = await fetchEmployee();  // Takes 500ms
  
  // Check if still current request
  if (currentRequestId !== requestIdRef.current) {
    return;                               // ✅ Ignore stale response!
  }
  
  setEmployee(empData);                   // ✅ Only if still current
  setBranchLoaded(true);
}

useEffect(() => {
  const currentRequestId = requestIdRef.current;
  
  watchLocation((loc) => {
    if (currentRequestId !== requestIdRef.current) {
      return;                             // ✅ Ignore from old employee!
    }
    setLocation(loc);
  });
  
  return () => clearWatch();              // ✅ Clean up on change
}, [isLoggedIn, employee?.id]);           // ✅ Re-create per employee

================================================================================

BEFORE: No State Reset (Cross-Contamination)
--------------------------------------------------------------------------------

function handleLogin() {
  // Old location/GPS data persists!
  // Old errors persist!
  
  setEmployee(newEmployee);
  
  // GPS validation uses:
  // - New employee's branch ✅
  // - Old employee's location ❌
  // - Old GPS errors ❌
}

AFTER: State Reset (Clean Slate)
--------------------------------------------------------------------------------

const resetAttendanceState = () => {
  requestIdRef.current += 1;              // Invalidate old requests
  setLocation(null);                      // Clear old location
  setGpsError('');                        // Clear old errors
  setAttendanceStatus('loading');         // Reset status
  setBranchLoaded(false);                 // Reset branch flag
  clearWatch(watchIdRef.current);         // Stop old GPS watch
};

function handleLogin() {
  resetAttendanceState();                 // ✅ Clean slate!
  
  setEmployee(newEmployee);
  
  // GPS validation uses:
  // - New employee's branch ✅
  // - New location (fresh) ✅
  // - No stale errors ✅
}

================================================================================

EXECUTION ORDER COMPARISON
--------------------------------------------------------------------------------

BEFORE (No Enforced Order):
  ┌─ User logs in as EMP001
  ├─ Branch fetch starts (500ms) ──────┐
  ├─ GPS watch starts                  │
  │                                     │
  ├─ GPS gets location (200ms)         │
  │  └─ Validates against ??? (no branch yet!)
  │     └─ Shows "loading..."          │
  │                                     │
  ├─ [User switches to EMP002]         │
  │  (Branch fetch still running)      │
  │                                     │
  └─ Branch data arrives (500ms) ──────┘
     └─ Updates state with EMP001 branch! ❌
        └─ GPS validates EMP002 location vs EMP001 branch! ❌
           └─ WRONG STATUS MESSAGE! ❌

AFTER (Strict Order):
  ┌─ User logs in as EMP001
  ├─ requestId = 1
  ├─ Branch fetch starts (500ms) ──────┐
  ├─ GPS watch starts (requestId=1)    │
  │                                     │
  ├─ GPS gets location (200ms)         │
  │  └─ branchLoaded = false           │
  │     └─ Shows "loading..." ✅       │
  │                                     │
  ├─ [User switches to EMP002]         │
  │  └─ requestId = 2                  │
  │     └─ State reset:                │
  │        - location = null           │
  │        - branchLoaded = false      │
  │        - GPS watch stopped         │
  │                                     │
  └─ EMP001 branch arrives (500ms) ────┘
     └─ requestId check: 1 !== 2
        └─ IGNORED! ✅

  ┌─ EMP002 branch fetch starts
  ├─ GPS watch starts (requestId=2)
  ├─ Branch arrives (300ms)
  │  └─ requestId check: 2 === 2 ✅
  │     └─ branchLoaded = true ✅
  │        └─ Shows "loading GPS..." ✅
  │
  ├─ GPS gets location (200ms)
  │  └─ requestId check: 2 === 2 ✅
  │     └─ Validates vs EMP002 branch ✅
  │        └─ CORRECT STATUS! ✅
  └─ Done

================================================================================

KEY DIFFERENCES
--------------------------------------------------------------------------------

Aspect                  | BEFORE            | AFTER
------------------------|-------------------|-----------------------------------
Status source           | Multiple checks   | Single enum
Request tracking        | None              | Versioned (requestId)
State on switch         | Persists          | Reset completely
GPS watch               | Shared            | Per employee (keyed by ID)
Branch validation       | Optional          | Required BEFORE GPS
Order enforcement       | None              | Strict priority
Stale updates           | Applied           | Ignored
Cross-contamination     | Possible          | Prevented

DEBUG VISIBILITY
--------------------------------------------------------------------------------

BEFORE:
  (No debug logging)
  User reports: "Status messages are wrong"
  Developer: "Can't reproduce, need more info"

AFTER:
  [DEBUG] Attendance state reset { requestId: 1 }
  [DEBUG] Starting GPS watch { requestId: 1, employee_id: 'e0a52...' }
  [DEBUG] Branch data loaded { employee_id: 'e0a52...', lat: 30.57 }
  [DEBUG] Ignoring outdated GPS update { currentRequestId: 1, latest: 3 }
  [DEBUG] Ready for check-in { distance: 25, allowedRadius: 50 }
  
  Developer: "Request 1 ignored because requestId is now 3. Working as expected."

PERFORMANCE IMPACT
--------------------------------------------------------------------------------

Memory:    +24 bytes (3 new state variables)
CPU:       +1 useEffect (minimal, early returns)
Network:   No change
Build:     No change (1.01 MB)

BACKWARD COMPATIBILITY
--------------------------------------------------------------------------------

✅ All UI text identical
✅ All behavior identical (when not switching)
✅ No API changes
✅ No database changes
✅ No breaking changes

================================================================================
